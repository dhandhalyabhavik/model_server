diff --git a/tensorflow/core/lib/io/cache.cc b/tensorflow/core/lib/io/cache.cc
index b5521b1752..feaa8d1b91 100644
--- a/tensorflow/core/lib/io/cache.cc
+++ b/tensorflow/core/lib/io/cache.cc
@@ -427,10 +427,10 @@ class ShardedLRUCache : public Cache {
     switch (limit - data) {
       case 3:
         h += static_cast<uint8_t>(data[2]) << 16;
-        ABSL_FALLTHROUGH_INTENDED;
+        [[fallthrough]];
       case 2:
         h += static_cast<uint8_t>(data[1]) << 8;
-        ABSL_FALLTHROUGH_INTENDED;
+        [[fallthrough]];
       case 1:
         h += static_cast<uint8_t>(data[0]);
         h *= m;

diff --git a/tensorflow/workspace2.bzl b/tensorflow/workspace2.bzl
index be571aaf1f8..a8765b08bd4 100644
--- a/tensorflow/workspace2.bzl
+++ b/tensorflow/workspace2.bzl
@@ -706,12 +706,12 @@ def _tf_repositories():
     tf_http_archive(
         name = "zlib",
         build_file = "//third_party:zlib.BUILD",
-        sha256 = "c3e5e9fdd5004dcb542feda5ee4f0ff0744628baf8ed2dd5d66f8ca1197cb1a1",
-        strip_prefix = "zlib-1.2.11",
+        sha256 = "b3a24de97a8fdbc835b9833169501030b8977031bcb54b3b3ac13740f846ab30",
+        strip_prefix = "zlib-1.2.13",
         system_build_file = "//third_party/systemlibs:zlib.BUILD",
         urls = [
-            "https://storage.googleapis.com/mirror.tensorflow.org/zlib.net/zlib-1.2.11.tar.gz",
-            "https://zlib.net/zlib-1.2.11.tar.gz",
+            "https://storage.googleapis.com/mirror.tensorflow.org/zlib.net/zlib-1.2.13.tar.gz",
+            "https://zlib.net/zlib-1.2.13.tar.gz",
         ],
     )

From 4e8774853436dc9b1f6867f62445580977f57fdf Mon Sep 17 00:00:00 2001
From: Rafal Sapala <rafal.a.sapala@intel.com>
Date: Fri, 5 May 2023 13:57:03 +0200
Subject: [PATCH] tf logging macros

---
 tensorflow/core/platform/default/BUILD        |   7 +
 tensorflow/core/platform/default/log_macros.h | 122 ++++++++++++++++++
 tensorflow/core/platform/default/logging.h    | 119 +----------------
 3 files changed, 130 insertions(+), 118 deletions(-)
 create mode 100644 tensorflow/core/platform/default/log_macros.h

diff --git a/tensorflow/core/platform/default/BUILD b/tensorflow/core/platform/default/BUILD
index 0856bb1edce..155c4fc8a8d 100644
--- a/tensorflow/core/platform/default/BUILD
+++ b/tensorflow/core/platform/default/BUILD
@@ -188,6 +188,12 @@ cc_library(
     ],
 )
 
+cc_library(
+    name = "log_macros",
+    hdrs = ["log_macros.h"],
+    visibility = ["//visibility:public"],
+)
+
 cc_library(
     name = "logging",
     srcs = ["logging.cc"],
@@ -199,6 +205,7 @@ cc_library(
     ],
     textual_hdrs = ["logging.h"],
     deps = [
+        ":log_macros",
         "//tensorflow/core/platform",
         "//tensorflow/core/platform:env_time",
         "//tensorflow/core/platform:macros",
diff --git a/tensorflow/core/platform/default/log_macros.h b/tensorflow/core/platform/default/log_macros.h
new file mode 100644
index 00000000000..96f3181588b
--- /dev/null
+++ b/tensorflow/core/platform/default/log_macros.h
@@ -0,0 +1,122 @@
+#pragma once
+#define LOG(severity) _TF_LOG_##severity
+
+// An instance of `LOG_EVERY_N` increments a hidden zero-initialized counter
+// every time execution passes through it and logs the specified message when
+// the counter's value is a multiple of `n`, doing nothing otherwise.  Each
+// instance has its own counter.  The counter's value can be logged by streaming
+// the symbol `COUNTER`.  `LOG_EVERY_N` is thread-safe.
+// Example:
+//
+//   for (const auto& user : all_users) {
+//     LOG_EVERY_N(INFO, 1000) << "Processing user #" << COUNTER;
+//     ProcessUser(user);
+//   }
+#define LOG_EVERY_N(severity, n)                       \
+  LOGGING_INTERNAL_STATEFUL_CONDITION(EveryN, true, n) \
+  LOG(severity)
+
+// CHECK dies with a fatal error if condition is not true.  It is *not*
+// controlled by NDEBUG, so the check will be executed regardless of
+// compilation mode.  Therefore, it is safe to do things like:
+//    CHECK(fp->Write(x) == 4)
+#define CHECK(condition)              \
+  if (TF_PREDICT_FALSE(!(condition))) \
+  LOG(FATAL) << "Check failed: " #condition " "
+// `LOG_FIRST_N` behaves like `LOG_EVERY_N` except that the specified message is
+// logged when the counter's value is less than `n`.  `LOG_FIRST_N` is
+// thread-safe.
+#define LOG_FIRST_N(severity, n)                       \
+  LOGGING_INTERNAL_STATEFUL_CONDITION(FirstN, true, n) \
+  LOG(severity)
+
+#ifdef IS_MOBILE_PLATFORM
+// Turn VLOG off when under mobile devices for considerations of binary size.
+#define VLOG_IS_ON(lvl) ((lvl) <= 0)
+
+#else
+
+// Otherwise, set TF_CPP_MAX_VLOG_LEVEL environment to update minimum log level
+// of VLOG, or TF_CPP_VMODULE to set the minimum log level for individual
+// translation units.
+#define VLOG_IS_ON(lvl)                                                     \
+  (([](int level, const char* fname) {                                      \
+    static const bool vmodule_activated =                                   \
+        ::tensorflow::internal::LogMessage::VmoduleActivated(fname, level); \
+    return vmodule_activated;                                               \
+  })(lvl, __FILE__))
+#endif
+
+#define VLOG(level)                                              \
+  TF_PREDICT_TRUE(!VLOG_IS_ON(level))                            \
+  ? (void)0                                                      \
+  : ::tensorflow::internal::Voidifier() &                        \
+          ::tensorflow::internal::LogMessage(__FILE__, __LINE__, \
+                                             tensorflow::INFO)
+
+// `DVLOG` behaves like `VLOG` in debug mode (i.e. `#ifndef NDEBUG`).
+// Otherwise, it compiles away and does nothing.
+#ifndef NDEBUG
+#define DVLOG VLOG
+#else
+#ifndef DVLOG
+#define DVLOG(verbose_level) \
+  while (false && (verbose_level) > 0) ::tensorflow::internal::LogMessageNull()
+#endif
+#endif
+
+
+// In optimized mode, use CheckOpString to hint to compiler that
+// the while condition is unlikely.
+#define CHECK_OP_LOG(name, op, val1, val2)                     \
+  while (::tensorflow::internal::CheckOpString _result{        \
+      ::tensorflow::internal::name##Impl(                      \
+          ::tensorflow::internal::GetReferenceableValue(val1), \
+          ::tensorflow::internal::GetReferenceableValue(val2), \
+          #val1 " " #op " " #val2)})                           \
+  ::tensorflow::internal::LogMessageFatal(__FILE__, __LINE__) << *(_result.str_)
+
+#define CHECK_OP(name, op, val1, val2) CHECK_OP_LOG(name, op, val1, val2)
+
+// CHECK_EQ/NE/...
+#define CHECK_EQ(val1, val2) CHECK_OP(Check_EQ, ==, val1, val2)
+#define CHECK_NE(val1, val2) CHECK_OP(Check_NE, !=, val1, val2)
+#define CHECK_LE(val1, val2) CHECK_OP(Check_LE, <=, val1, val2)
+#define CHECK_LT(val1, val2) CHECK_OP(Check_LT, <, val1, val2)
+#define CHECK_GE(val1, val2) CHECK_OP(Check_GE, >=, val1, val2)
+#define CHECK_GT(val1, val2) CHECK_OP(Check_GT, >, val1, val2)
+#define CHECK_NOTNULL(val)                               \
+  ::tensorflow::internal::CheckNotNull(__FILE__, __LINE__, \
+                                       "'" #val "' Must be non NULL", (val))
+
+
+#ifndef NDEBUG
+// DCHECK_EQ/NE/...
+#define DCHECK(condition) CHECK(condition)
+#define DCHECK_EQ(val1, val2) CHECK_EQ(val1, val2)
+#define DCHECK_NE(val1, val2) CHECK_NE(val1, val2)
+#define DCHECK_LE(val1, val2) CHECK_LE(val1, val2)
+#define DCHECK_LT(val1, val2) CHECK_LT(val1, val2)
+#define DCHECK_GE(val1, val2) CHECK_GE(val1, val2)
+#define DCHECK_GT(val1, val2) CHECK_GT(val1, val2)
+
+#else
+
+#define DCHECK(condition) \
+  while (false && (condition)) LOG(FATAL)
+
+// NDEBUG is defined, so DCHECK_EQ(x, y) and so on do nothing.
+// However, we still want the compiler to parse x and y, because
+// we don't want to lose potentially useful errors and warnings.
+// _DCHECK_NOP is a helper, and should not be used outside of this file.
+#define _TF_DCHECK_NOP(x, y) \
+  while (false && ((void)(x), (void)(y), 0)) LOG(FATAL)
+
+#define DCHECK_EQ(x, y) _TF_DCHECK_NOP(x, y)
+#define DCHECK_NE(x, y) _TF_DCHECK_NOP(x, y)
+#define DCHECK_LE(x, y) _TF_DCHECK_NOP(x, y)
+#define DCHECK_LT(x, y) _TF_DCHECK_NOP(x, y)
+#define DCHECK_GE(x, y) _TF_DCHECK_NOP(x, y)
+#define DCHECK_GT(x, y) _TF_DCHECK_NOP(x, y)
+
+#endif
\ No newline at end of file
diff --git a/tensorflow/core/platform/default/logging.h b/tensorflow/core/platform/default/logging.h
index 27331b2bcd1..959a136b89c 100644
--- a/tensorflow/core/platform/default/logging.h
+++ b/tensorflow/core/platform/default/logging.h
@@ -35,6 +35,7 @@ limitations under the License.
 #include "absl/strings/string_view.h"
 #include "tensorflow/core/platform/macros.h"
 #include "tensorflow/core/platform/types.h"
+#include "log_macros.h"
 
 // TODO(mrry): Prevent this Windows.h #define from leaking out of our headers.
 #undef ERROR
@@ -114,43 +115,6 @@ class LogMessageNull : public std::basic_ostringstream<char> {
 
 #define _TF_LOG_QFATAL _TF_LOG_FATAL
 
-#define LOG(severity) _TF_LOG_##severity
-
-#ifdef IS_MOBILE_PLATFORM
-
-// Turn VLOG off when under mobile devices for considerations of binary size.
-#define VLOG_IS_ON(lvl) ((lvl) <= 0)
-
-#else
-
-// Otherwise, set TF_CPP_MAX_VLOG_LEVEL environment to update minimum log level
-// of VLOG, or TF_CPP_VMODULE to set the minimum log level for individual
-// translation units.
-#define VLOG_IS_ON(lvl)                                                     \
-  (([](int level, const char* fname) {                                      \
-    static const bool vmodule_activated =                                   \
-        ::tensorflow::internal::LogMessage::VmoduleActivated(fname, level); \
-    return vmodule_activated;                                               \
-  })(lvl, __FILE__))
-
-#endif
-
-#define VLOG(level)                                              \
-  TF_PREDICT_TRUE(!VLOG_IS_ON(level))                            \
-  ? (void)0                                                      \
-  : ::tensorflow::internal::Voidifier() &                        \
-          ::tensorflow::internal::LogMessage(__FILE__, __LINE__, \
-                                             tensorflow::INFO)
-
-// `DVLOG` behaves like `VLOG` in debug mode (i.e. `#ifndef NDEBUG`).
-// Otherwise, it compiles away and does nothing.
-#ifndef NDEBUG
-#define DVLOG VLOG
-#else
-#define DVLOG(verbose_level) \
-  while (false && (verbose_level) > 0) ::tensorflow::internal::LogMessageNull()
-#endif
-
 class LogEveryNState {
  public:
   bool ShouldLog(int n);
@@ -217,26 +181,6 @@ class LogEveryNSecState {
            logging_internal_stateful_condition_do_log;              \
            logging_internal_stateful_condition_do_log = false)
 
-// An instance of `LOG_EVERY_N` increments a hidden zero-initialized counter
-// every time execution passes through it and logs the specified message when
-// the counter's value is a multiple of `n`, doing nothing otherwise.  Each
-// instance has its own counter.  The counter's value can be logged by streaming
-// the symbol `COUNTER`.  `LOG_EVERY_N` is thread-safe.
-// Example:
-//
-//   for (const auto& user : all_users) {
-//     LOG_EVERY_N(INFO, 1000) << "Processing user #" << COUNTER;
-//     ProcessUser(user);
-//   }
-#define LOG_EVERY_N(severity, n)                       \
-  LOGGING_INTERNAL_STATEFUL_CONDITION(EveryN, true, n) \
-  LOG(severity)
-// `LOG_FIRST_N` behaves like `LOG_EVERY_N` except that the specified message is
-// logged when the counter's value is less than `n`.  `LOG_FIRST_N` is
-// thread-safe.
-#define LOG_FIRST_N(severity, n)                       \
-  LOGGING_INTERNAL_STATEFUL_CONDITION(FirstN, true, n) \
-  LOG(severity)
 // `LOG_EVERY_POW_2` behaves like `LOG_EVERY_N` except that the specified
 // message is logged when the counter's value is a power of 2.
 // `LOG_EVERY_POW_2` is thread-safe.
@@ -254,13 +198,6 @@ class LogEveryNSecState {
   LOGGING_INTERNAL_STATEFUL_CONDITION(EveryNSec, true, n_seconds) \
   LOG(severity)
 
-// CHECK dies with a fatal error if condition is not true.  It is *not*
-// controlled by NDEBUG, so the check will be executed regardless of
-// compilation mode.  Therefore, it is safe to do things like:
-//    CHECK(fp->Write(x) == 4)
-#define CHECK(condition)              \
-  if (TF_PREDICT_FALSE(!(condition))) \
-  LOG(FATAL) << "Check failed: " #condition " "
 
 // Function is overloaded for integral types to allow static const
 // integrals declared in classes and not defined to be used as arguments to
@@ -394,60 +331,6 @@ TF_DEFINE_CHECK_OP_IMPL(Check_GE, >=)
 TF_DEFINE_CHECK_OP_IMPL(Check_GT, >)
 #undef TF_DEFINE_CHECK_OP_IMPL
 
-// In optimized mode, use CheckOpString to hint to compiler that
-// the while condition is unlikely.
-#define CHECK_OP_LOG(name, op, val1, val2)                     \
-  while (::tensorflow::internal::CheckOpString _result{        \
-      ::tensorflow::internal::name##Impl(                      \
-          ::tensorflow::internal::GetReferenceableValue(val1), \
-          ::tensorflow::internal::GetReferenceableValue(val2), \
-          #val1 " " #op " " #val2)})                           \
-  ::tensorflow::internal::LogMessageFatal(__FILE__, __LINE__) << *(_result.str_)
-
-#define CHECK_OP(name, op, val1, val2) CHECK_OP_LOG(name, op, val1, val2)
-
-// CHECK_EQ/NE/...
-#define CHECK_EQ(val1, val2) CHECK_OP(Check_EQ, ==, val1, val2)
-#define CHECK_NE(val1, val2) CHECK_OP(Check_NE, !=, val1, val2)
-#define CHECK_LE(val1, val2) CHECK_OP(Check_LE, <=, val1, val2)
-#define CHECK_LT(val1, val2) CHECK_OP(Check_LT, <, val1, val2)
-#define CHECK_GE(val1, val2) CHECK_OP(Check_GE, >=, val1, val2)
-#define CHECK_GT(val1, val2) CHECK_OP(Check_GT, >, val1, val2)
-#define CHECK_NOTNULL(val)                                 \
-  ::tensorflow::internal::CheckNotNull(__FILE__, __LINE__, \
-                                       "'" #val "' Must be non NULL", (val))
-
-#ifndef NDEBUG
-// DCHECK_EQ/NE/...
-#define DCHECK(condition) CHECK(condition)
-#define DCHECK_EQ(val1, val2) CHECK_EQ(val1, val2)
-#define DCHECK_NE(val1, val2) CHECK_NE(val1, val2)
-#define DCHECK_LE(val1, val2) CHECK_LE(val1, val2)
-#define DCHECK_LT(val1, val2) CHECK_LT(val1, val2)
-#define DCHECK_GE(val1, val2) CHECK_GE(val1, val2)
-#define DCHECK_GT(val1, val2) CHECK_GT(val1, val2)
-
-#else
-
-#define DCHECK(condition) \
-  while (false && (condition)) LOG(FATAL)
-
-// NDEBUG is defined, so DCHECK_EQ(x, y) and so on do nothing.
-// However, we still want the compiler to parse x and y, because
-// we don't want to lose potentially useful errors and warnings.
-// _DCHECK_NOP is a helper, and should not be used outside of this file.
-#define _TF_DCHECK_NOP(x, y) \
-  while (false && ((void)(x), (void)(y), 0)) LOG(FATAL)
-
-#define DCHECK_EQ(x, y) _TF_DCHECK_NOP(x, y)
-#define DCHECK_NE(x, y) _TF_DCHECK_NOP(x, y)
-#define DCHECK_LE(x, y) _TF_DCHECK_NOP(x, y)
-#define DCHECK_LT(x, y) _TF_DCHECK_NOP(x, y)
-#define DCHECK_GE(x, y) _TF_DCHECK_NOP(x, y)
-#define DCHECK_GT(x, y) _TF_DCHECK_NOP(x, y)
-
-#endif
-
 // These are for when you don't want a CHECK failure to print a verbose
 // stack trace.  The implementation of CHECK* in this file already doesn't.
 #define QCHECK(condition) CHECK(condition)
-- 
2.25.1

